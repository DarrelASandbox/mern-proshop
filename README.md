## About The Project

- MERN eCommerce From Scratch
- Build an eCommerce platform from the ground up with React, Redux, Express & MongoDB
- Tutorial for ProShop
- <b style="color:red;">NOT MEANT FOR PRODUCTION (Refer to Notes section below)</b>
- [GitHub - Brad Traversy](https://github.com/bradtraversy)
- [YouTube - Coding with Basir](https://www.youtube.com/CodingwithBasir)

&nbsp;

## Notes

- [Bootswatch - bootstrap.min.css](https://bootswatch.com/)
- [stackoverflow - Why isn't React considered MVC?](https://stackoverflow.com/questions/53729411/why-isnt-react-considered-mvc)

&nbsp;

---

&nbsp;

> <b>Mehdi: </b>Why duplicate data in orderModel?
>
> at 09:52 in "Modeling Our Data". Why the orderModel has a field called orderItems with (name, price...) while we already have that data in the productModel. Why not just have an array ids of products in orderModel?

> <b>Leonidas: </b>I guess you could go that way as well. The you would have smaller documents in the db, but whenever you needed that data you would need to populate from the productModel with the related id and this would require extra logic implemented and more roundtrips to fetch the data.

> <b>Niko: </b>The order items and shop products are two different entities and it's important to differentiate between them. The order item usually contains a reference to the product, but also copies of the important product properties at the time it was sold (name, price, tax class, etc). Otherwise when product data is changed (which is pretty common), you would also change all existing orders. Besides that - order items usually hold a lot of additional information that is specific to it's order (discounts, extras like gift wrapping, tax rates)

&nbsp;

---

&nbsp;

> <b>Dhruv: </b>Why we can't use arrow function with userSchema methods?
>
> ```js
> userSchema.methods.matchPassword = async (enteredPassword) => {};
> ```
>
> while using arrow function here, i am getting an error that password is not defined.
>
> "message": "Cannot read property 'password' of undefined", "stack": "TypeError: Cannot read property 'password' of undefined\n at model.userSchema.methods.matchPassword (file:///proshop/backend/models/userModel.js:31:53)\n at file:////proshop/backend/controllers/userController.js:11:27\n at processTicksAndRejections (internal/process/task_queues.js:97:5)" }

> <b>Bassir: </b>because "this" in the arrow function point to the parent object and there is no parent object or function there. so you need to use regular functions.

> <b>Dhruv: </b>Thanks, for the reply. Could u please explain how we have parent object in regular function but not in arrow function. By the way, The course is really helpful.

> <b>Zhing Jieh Jack: </b>In general, <code>this</code> is a special variable that points to either the globalObject (e.g window), caller (instance), or Class.
> For an instance's function, <code>this</code> points to the instance. Hence we can do <code>this.password</code> as <code>this</code> points to user instance.
> For a static function (Class's function), <code>this</code> points to the Class. Hence we can do <code>this.find({})</code> as <code>this</code> points to User model.
> For an arrow function, <code>this</code> does not point to the caller (instance) or its Class, it points to the context where the arrow function is called.
>
> [This MDN document](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this) should clarify more

> <b>David: </b>Arrow functions do not get hoisted and "this" is set to window object. Its just how they work. You have to bind "this" manually. It would be easier to just write it as a normal function in this case

&nbsp;

---

&nbsp;

> <b>Roy: </b>Possible security issue with /api/orders/:id
>
> While the order IDs are generated by Mongo and hard to guess, doesn't this endpoint pose a potential security/privacy issue? The only check is that the user is a valid, logged in user and not that the user is the one who placed the order. If I happen to know or guess someone's Order ID I could return all of their personal data from the order (name, email, address)

> <b>Bassir: </b>You can not guess the mongodb id because it is unique id. about have a check if user is admin or use is owner of the order I am with you. it's been noted.

> <b>Fraser: </b>I modified my getOrderById function to check if the request was from an admin or if the order user ID was equal to the request user ID:

```js
// @desc    Get order by ID
// @route   GET /api/orders/:id
// @access  Private
const getOrderById = asyncHandler(async (req, res) => {
  const order = await Order.findById(req.params.id).populate(
    'user',
    'name email'
  );

  if (order && (req.user.isAdmin || order.user._id.equals(req.user._id))) {
    res.json(order);
  } else {
    res.status(404);
    throw new Error('Order not found');
  }
});
```

> One would expect to be able to compare order.user.\_id === req.user.\_id but this didn't work. After some investigation I came across [this answer](https://stackoverflow.com/questions/11060213/mongoose-objectid-comparisons-fail-inconsistently) which solved the problem.

> <b>Tamunoemi Benson: </b> Hi @roy you can check if users are the owner of the order by the below

```js
export const getOrderById = asyncHandler(async (req, res) => {
  const order = await Order.findById(req.params.id).populate(
    'user',
    'name email'
  );
  if (order && order.user._id.toString() !== req.user._id.toString()) {
    res.status(401);
    throw new Error('Unauthorized Action');
  } else if (order) {
    res.json(order);
  } else {
    res.status(404);
    throw new Error('No order found');
  }
});
```

&nbsp;

---

&nbsp;

> <b>Valdis: </b>Security issue - you can update order to isPaid, without going through payment!
> Please have fun trying it yourself! Place order, but don't pay for it, then follow instructions below. I'm on lesson 61. All I tried is - sent PUT request via Postman to API route, include your token in headers, and in "body" put JSON data like this:

```js
{
    "id": "Somestring",
    "status": "sortOfSuccess",
    "update_time": "Tomorrow",
    "payer": {"email_address": "badguy@example.com"}
}
```

> Send PUT request to your <code>/api/orders/:id/pay</code>, obviously include your order id,

> Or send it to Brads original website:
> <code> http://proshopapp.herokuapp.com/api/orders/<put-your-order-id-here>/pay</code>
>
> Dear Brad, if you are reading this, please check paymentResult in your database for this order: <code>http://proshopapp.herokuapp.com/order/60298a48b01e61000418c5a2</code>
>
> And here comes the question - how do we protect this route??

> <b>Valdis: </b>And here comes reply to myself :))
>
> I think fixing this is not a big deal. We can make API route unguessable, like this
> <code>/api/orders/&lt;some-unguesssable-string&gt;/:id/pay</code>
>
> In addition, as I just found from lesson 63 - we have a complicated object coming from PayPal as a response, so we have plenty of options to mess with that - not necessary the way shown in this lesson. So what I did in my previous post is not that clever, but I will keep both comments, so people know there's a potential risk if we all stick to the same standard.

> <b>Begzod: </b>you are right, but it is still risky to try to protect it using that 'unguessable' route. The better way is I think somehow get the payment confirmed in the backend by sending a confirmation request to Paypal API.

> <b>Allan: </b>Indeed, this seems to be a security loophole that requires URGENT rectification. Unfortunately, relying on PayPal API for "confirmation" may not be useful on orders using other payment options such as Cash-on-Delivery (COD), Cash-on-Pickup (COP), etc. COD and COP, requires that an Admin (or external Courier API) mark the order as Paid.

> In this regard, I am interested in adopting Valdis' idea, but to utilize a secret key (include in <code>.env</code>), hash it with another variable such as the Order ID, then require it when calling the <code>/pay</code> route.

&nbsp;

---

&nbsp;

> <b>Rafal: </b>Is it safe?
>
> Is it safe to update the payment without any confirmation? When I make an order I could sent the PUT request to the API and it would update without actual payment. If the seller wouldn't check if the payment was actually received he could sent me the item. Is there a way to check if the payment was received with react-paypal-button-v2 via backend?

> <b>Bassir: </b>use this [api](https://developer.paypal.com/docs/api/payments/v2/) to confirm paypal payment

&nbsp;

---

&nbsp;

> <b>Roy: </b>Why are we actually removing products from the DB versus giving them a isDeleted field of true? Deleted products will break past oders
> If users were to order products, and then 3 months later the site owner wanted to remove the product from the site simply deleting the product will result in errors in viewing past orders.
>
> Should we not be adding a isDeleted (or whatever) field to products, and simply toggling products to isDeleted versus removing them? Then past orders can load the data, but we can filter store lists by that field.
>
> (This even to a lesser extent should carry over to users. While a user might 'delete' their own account and staff could even delete an account, it shouldn't really be removed from the DB. If admin are reviewing orders and looking for past orders due to a complaint or what not they couldn't find user information as it was simply removed.)

> <b>Bassir: </b>yes. you are right. setting isDeleted to true is a better way in real scenario.

> <b>Tomasz: </b>Good point, but I can see some problems with isDeleted approach when it comes to user.
>
> It is not completely unrealistic that user deletes an account and some time later wants to register again. Using the same email adress will give an error from db since we keep storing users profile. Duplicate email error will clearly inform user that his/her data is still stored in our db. Aren't we legaly obligated to remove that data on user's request? I know facebook e.g. keeps all the data forever but not sure it is the way to go.
>
> We could test isDeleted prop when duplicate email and run update instead of create, but then user logs into new account and sees all the previous orders... is that a good experience? Personally I would expect having a clear history with new account, but I am not sure about it.
>
> Shoudn't we populate order with user data when order is created and store information in order object rather then read it by reference every time we retrive order from db? That gives us user data we may need in regards to an order and allows user to delete his/her profile without breaking the orders. An order can only be created by one user so that shouldn't bring that much additional load on db especialy we don't need all the user data in the order just some of them.
>
> isDeleted approach could work with products only and orders should never be deleted...
>
> I am very curious what are your thoughts about it.

> <b>Roy: </b>The idea of duplicating some of the product info relevant to the order into the order row can work, but also wasn't covered here. That's a design choice - either have enough info saved to display orders as needed or keep the products long(er) term so you can view orders and even the full product listing.
>
> In terms of the user, again design choice. When you query to see if the user exists you can exclude any returns with the isDeleted flag. If the results are 0 (either never registered, or registered and deleted) then create a new user. You could even go a step further with that query. If it returns an isDeleted user account you can offer a recovery option that requires more information than just the email -- maybe past order numbers or something private -- and if the user provides it then restore the account.
>
> But with the idea of a new account, then it has a new, unique ID. All your 'is there an order' or whatever queries should use that and never return results from a different user ID (from the old user account).
>
> In general though you need to do something to keep some records at least for the short term just for accounting, delivers, etc.

&nbsp;

---

&nbsp;
